<?xml version="1.0"?>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<binding id="vivibuttonpanel">
    <content>
      <xul:grid anonid="grid" xbl:inherits="class,pack,orient,collapsed,hidden,flex,align,dir">
          <xul:columns anonid="columns" />
          <xul:rows anonid="rows" />
      </xul:grid>
      <children />
    </content>

    <resources>
      <stylesheet src="chrome://vivipos/skin/bindings/vivibuttonpanel.css" />
    </resources>

  <implementation>

    <field name="buttons" >null</field>
    <field name="buttonCount" >0</field>

    <field name="_startOffset" >-1</field>
    <field name="_currentIndex" >-1</field>

    <field name="_selectedCount" >0</field>
    <field name="_selectedItems" >null</field>
    <field name="_selectedItemGroups" >null</field>

    <property name="rowCount" onget="return this.datasource.rowCount;" readonly="true" />

    <property name="startOffset" onget="return this._startOffset;">
        <setter><![CDATA[

            var preStartOffset = this._startOffset;
            var offset = 0;
            if (val <= 0) offset = 0;
            else if(val >= this.rowCount ) {
                var row = (Math.ceil(this.rowCount / this.buttonCount)-1) ;
                row = row > 0 ? row : 0;
                offset =  row * this.buttonCount;
            }
            else offset = val;

            this._startOffset = offset; 

            // redraw
            if(this._startOffset != preStartOffset) {
                this.render();
            }

            return offset;
        ]]>
        </setter>
    </property>

    <property name="grid" onget="return document.getAnonymousElementByAttribute(this, 'anonid', 'grid');" readonly="true" />
    <property name="cols" onget="return this.getAttribute('cols')" onset="this.setAttribute('cols', val); return val;"/>
    <property name="rows" onget="return this.getAttribute('rows')" onset="this.setAttribute('rows', val); return val;"/>
    <property name="seltype" onget="return (this.getAttribute('seltype') ||'single').toLowerCase();" onset="this.setAttribute('seltype', val); return val;"/>

    <property name="buttonClass" onget="return this.getAttribute('buttonClass')" onset="this.setAttribute('buttonClass', val); return val;"/>

    <property name="labelField"
                onget="return this.getAttribute('labelField')"
                onset="this.setAttribute('labelField', val); return val;"/>

    <property name="aclField"
                onget="return this.getAttribute('aclField')"
                onset="this.setAttribute('aclField', val); return val;"/>

    <property name="imageField"
                onget="return this.getAttribute('imageField')"
                onset="this.setAttribute('imageField', val); return val;"/>

    <property name="buttonTagName"
                onget="return this.getAttribute('buttonTagName')"
                onset="this.setAttribute('buttonTagName', val); return val;"/>

    <property name="currentIndex" onget="return this._currentIndex;" onset="this._currentIndex = val; return val;"/>

    <property name="selectedIndex" onget="return this.currentIndex;" onset="return this.currentIndex = val;" />

    <property name="selectedCount" onget="return this._selectedCount;" onset="return this._selectedCount = val;" />
    
    <property name="selectedItems" onget="return this._selectedItems;">
        <setter>
            <![CDATA[
                if(val.constructor.name == 'Array') {
                    this._selectedItems = val;
                    this._selectedCount = val.length;
                    this.updateSelectedItemState();
                }
                return val;
            ]]>
        </setter>
    </property>

    <property name="boxObject" onget="return this.grid.boxObject;" readonly="true" />

    <property name="boxHeight" onget="return this.boxObject.height;" readonly="true" />

    <property name="boxWidth" onget="return this.boxObject.width;" readonly="true" />

    <property name="datasource" onget="return this.getDatasource();" onset="return this.setDatasource(val);"/>

    <property name="value">
        <getter>
            <![CDATA[
                if (!this.datasource) return this.selectedItems.join(',');

                if (typeof this.datasource['getValue'] == 'function') {
                    return this.datasource.getValue();
                }else {
                    return this.selectedItems.join(',');
                }

            ]]>
        </getter>
        <setter>
            <![CDATA[

                if (val == null || typeof val == 'undefined' ) return;

                if (!this.datasource) {
                    var _selectedItems = (val+"").length > 0 ? (val+"").split(',') : [] ;

                    // convert to int
                    for (var i = 0; i < _selectedItems.length; i++) {
                        _selectedItems[i] = parseInt(_selectedItems[i]);
                    };
                    return this.selectedItems = _selectedItems ;
                }

                if (typeof this.datasource['setValue'] == 'function') {
                    return this.datasource.setValue(val);
                }else {
                    var _selectedItems = (val+"").length > 0 ? (val+"").split(',') : [] ;

                    // convert to int
                    for (var i = 0; i < _selectedItems.length; i++) {
                        _selectedItems[i] = parseInt(_selectedItems[i]);
                    };
                    return this.selectedItems = _selectedItems ;
                }

            ]]>
        </setter>
    </property>

    
    <constructor>
    <![CDATA[
    
        // GREUtils.log('init vivibuttonpanel constructor ' + this.getAttribute('rows'));

        this.initGrid();

        this._startOffset = -1;
        this._currentIndex = -1;
        this._selectedCount = 0;
        this._selectedItems = [];
        this._selectedItemGroups = {};

        var self = this;

        // resizeButtons
        this.ready = false;
        this.readyRuned = false;

        this.ready = function() {
            if(!self.readyRuned) {
                self.resizeButtons();
                self.readyRuned = true;
            }
        };

        // createElement
        this.addEventListener('load', this.ready, true);

        // static .xul
        window.addEventListener('load', this.ready, true);

    ]]>
    </constructor>

    <destructor>
    <![CDATA[

        if (this.ready) {
            window.removeEventListener('load', this.ready, true);
        }
        
    ]]>
    </destructor>


    <method name="initGrid">
        <body><![CDATA[

            // GREUtils.log('init vivibuttonpanel grid ' + this.parentNode.parentNode.id);
            var buttons = [];
            var imageValidate = this.getAttribute('validate');
            var buttonHeight = this.getAttribute('buttonHeight');
            var buttonTagName = this.buttonTagName || 'vivibutton';

            // init columns
            var columnsObj = document.getAnonymousElementByAttribute(this, 'anonid', 'columns');
            GeckoJS.Helper.removeAllChildren(columnsObj);

            var crop = this.getAttribute('crop');
            var pre = this.getAttribute('pre');

            var cols = parseInt(this.cols) || 0;

            for(let i=0; i < cols ; i++) {

                let column = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","column");
                column.setAttribute("flex", 1);
                columnsObj.appendChild(column);
            }


            // init rows
            var rowsObj = document.getAnonymousElementByAttribute(this, 'anonid', 'rows');
            GeckoJS.Helper.removeAllChildren(rowsObj);

            var rows = parseInt(this.rows) || 0;

            for(let i=0; i < rows ; i++) {

                let row = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul","row");

                // allow row to flex only if buttonHeight is not set
                row.setAttribute("flex", (buttonHeight) ? 0 : 1);

                for(let j=0; j < cols ; j++) {
                
                    let btn = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", buttonTagName);
                    let $btn = $(btn);

                    btn.setAttribute("flex", 1);
                    btn.setAttribute("anonid", i*cols+j);
                    if (imageValidate != null) btn.setAttribute('validate', imageValidate);

                    if (this.buttonClass) btn.setAttribute('class', this.buttonClass);
                    if(crop) btn.setAttribute('crop', crop);
                    if(pre) btn.setAttribute('pre', pre);
                    if(buttonHeight) {
                        $btn.css({
                            'max-height': buttonHeight + 'px',
                            'height': buttonHeight + 'px',
                            'min-height': buttonHeight + 'px'
                        });
                    }

                    // not use type and group attribute
                    // @see chrome://global/content/bindings/button.xml#button-base
                    // button use this.parentNode.getElementsByAttribute("group") , slow!!!

                    btn.setAttribute('disabled', true);
                    
                    buttons.push(btn);
                    row.appendChild(btn);
                }

                rowsObj.appendChild(row);
            }

            this.buttons = buttons;
            this.buttonCount = cols * rows;

        ]]>  
        </body>
    </method>

    <method name="getDatasource">
        <body><![CDATA[
            if (!this._datasource) this._datasource = new GeckoJS.NSITreeViewArray([]);
            return this._datasource;
        ]]>  
        </body>
    </method>


    <method name="setDatasource">
        <parameter name="datasource"/>
        <body><![CDATA[

            if (datasource) {
                if (datasource.constructor.name == 'Array') {
                    this.getDatasource().data = datasource;
                }else if (typeof datasource.getCellText == 'function'){
                    this._datasource = datasource;
                    this._datasource.setTree(this);
                }
                this.setAttribute('datasource', this._datasource);
            }
            this._selectedCount = 0;
            this._selectedItems = [];
            this._selectedItemGroups = {};
            this._startOffset = -1;
            this._currentIndex = -1;

            this.refresh();
            return this.getDatasource();
        ]]>  
        </body>
    </method>


    <method name="scrollByLines">
        <parameter name="numLines"/>
        <body><![CDATA[

            this.startOffset += numLines*parseInt(this.cols);

        ]]>  
        </body>
    </method>

    <method name="scrollByPages">
        <parameter name="numPages"/>
        <body><![CDATA[
            this.startOffset += numPages*this.buttonCount;

        ]]>  
        </body>
    </method>


    <method name="scrollToRow">
        <parameter name="index"/>
        <body><![CDATA[

            this.startOffset = index;

        ]]>  
        </body>
    </method>


    <method name="getButtonSelectType">
        <parameter name="index"/>
        <body><![CDATA[


            var seltype = this.seltype;

            if (seltype != 'mix') return seltype;

            // GREUtils.log('vivibuttonpanel getButtonSelectType ' );

            var rowCount = this.rowCount;

            if (index >= rowCount ) return seltype;

            var datasource = this.getDatasource();

            if(!datasource) return seltype;

            if (typeof datasource.getSelectType == 'function') {
                return datasource.getSelectType(index);
            }

        ]]>
        </body>
    </method>

    <method name="getButtonSelectGroup">
        <parameter name="index"/>
        <body><![CDATA[

            var seltype = this.seltype;

            if (seltype != 'mix' ) return 'default';

            //GREUtils.log('vivibuttonpanel getButtonSelectGroup ' );

            var rowCount = this.rowCount;

            if (index >= rowCount ) return 'default';

            var datasource = this.getDatasource();

            if(!datasource) return 'default';

            if (typeof datasource.getSelectGroup == 'function') {
                return datasource.getSelectGroup(index);
            }

        ]]>
        </body>
    </method>


    <method name="renderButton">
        <parameter name="index" />
        <body><![CDATA[

            var buttons = this.__buttons;
            var buttonCount = this.__buttonCount;
            var datasource = this.__datasource;
            var labelField = this.__labelField;
            var aclField = this.__aclField;
            var imageField = this.__imageField;
            var buttonClass = this.__buttonClass;
            var selectedItems = this.__selectedItems;
            var rowCount = this.__rowCount;
            var startOffset = this.__startOffset;

            var hasRole = true;
            var endOffset = startOffset + buttonCount;

            if (index < startOffset || index > endOffset) return ;

            let i = index - startOffset ;
            let row = index;


            // GREUtils.log('renderButton ' + index );

            if (GeckoJS.Array.inArray(row, selectedItems) != -1) {
                buttons[i].setAttribute('selected', true);
                buttons[i].setAttribute('checked', true);
            }else {
                buttons[i].removeAttribute('selected');
                buttons[i].removeAttribute('checked');
            }

            if (row >= rowCount) {

                    buttons[i].setAttribute('disabled', true);

                    if(typeof buttons[i]['setLabel'] == 'function') {
                        // vivibutton or compatible
                        buttons[i].setLabel("");
                        buttons[i].setImage("");
                    } else {
                        buttons[i].setAttribute('label', "");
                        buttons[i].setAttribute('image', "");
                    }                   

                    if (buttonClass) buttons[i].className = buttonClass;

            }else {


                    let role = (aclField.length > 0) ? datasource.getCellText(row, {id: aclField}) : null;

                    if (role && role.length > 0) {
                        if(GeckoJS && GeckoJS.AclComponent && typeof GeckoJS.AclComponent.isUserInRole == 'function') {
                            hasRole = GeckoJS.AclComponent.isUserInRole(role);
                        }else {
                            hasRole = false;
                        }
                    }

                    buttons[i].setAttribute('disabled', !hasRole);

                    if (buttonClass) buttons[i].className = buttonClass;

                    let text = datasource.getCellText(row, {id: labelField});

                    if(typeof buttons[i]['setLabel'] == 'function') {
                        buttons[i].setLabel(text);
                    }else {
                        buttons[i].setAttribute('label', text);
                    }

                    let image = datasource.getImageSrc(row, {id: imageField});
                    if (image) {

                        if(typeof buttons[i]['setImage'] == 'function') {
                            buttons[i].setImage(image);
                        }else {
                            buttons[i].setAttribute('image', image);
                        }

                    }else {

                        if(typeof buttons[i]['setImage'] == 'function') {
                            buttons[i].setImage('');
                        }else {
                            buttons[i].setAttribute('image', '');
                        }

                    }

                    if (typeof datasource.renderButton == 'function') {
                        datasource.renderButton(row, buttons[i]);
                    }

            }


        ]]>
        </body>
    </method>


    <method name="render">
        <body><![CDATA[

            this.__buttons = this.buttons;
            this.__buttonCount = this.buttonCount;
            this.__datasource = this.getDatasource();
            this.__labelField = this.labelField;
            this.__aclField = this.aclField;
            this.__imageField = this.imageField;
            this.__buttonClass = this.buttonClass;
            this.__selectedItems = this.selectedItems;
            this.__rowCount = this.rowCount;
            this.__startOffset = this.startOffset;

            var buttonCount = this.buttonCount;
            var startOffset = this.startOffset;

            for(let i=0; i < buttonCount ; i++) {

                let row = startOffset + i;

                this.renderButton(row);

            }

        ]]>  
        </body>
    </method>

    <method name="refresh">
        <body><![CDATA[

            // GREUtils.log('vivibutton panel refresh ' + this.parentNode.parentNode.id);

            var evt = document.createEvent('Event');
            evt.initEvent("refresh", true, false);
            this.canceled = this.dispatchEvent(evt);

            if ((this.getAttribute('ensureVisible').toLowerCase() == 'true') && this.selectedIndex > -1) {
                var pageSize = parseInt(this.rows) * parseInt(this.cols);
                var pageOffset = Math.floor(this.selectedIndex / pageSize);
                this._startOffset = pageOffset * pageSize;
            }

            this._startOffset = (this._startOffset < 0) ? 0 : this._startOffset;
            //if (this._startOffset > this.rowCount) this._startOffset = 0;
            // this.startOffset = this._startOffset;
            this.render();

        ]]>  
        </body>
    </method>

    <method name="invalidate">
        <body><![CDATA[

            // GREUtils.log('vivibutton panel invalidate ' + this.parentNode.parentNode.id);
            this.refresh();

        ]]>
        </body>
    </method>

    <method name="invalidateRange">
        <parameter name="startIndex" />
        <parameter name="endIndex" />
        <body><![CDATA[


            this.__buttons = this.buttons;
            this.__buttonCount = this.buttonCount;
            this.__datasource = this.getDatasource();
            this.__labelField = this.labelField;
            this.__aclField = this.aclField;
            this.__imageField = this.imageField;
            this.__buttonClass = this.buttonClass;
            this.__selectedItems = this.selectedItems;
            this.__rowCount = this.rowCount;
            this.__startOffset = this.startOffset;

            var buttonCount = this.buttonCount;
            var startOffset = this.startOffset;
            var endOffset = startOffset+buttonCount;

            if ( startIndex < startOffset || startIndex > endOffset) return;
            if (endIndex < startOffset || endIndex > endOffset) return;

            for(let i=startIndex; i < endIndex ; i++) {

                this.renderButton(i);

            }

        ]]>
        </body>
    </method>


    <method name="invalidateRow">
        <parameter name="index" />
        <body><![CDATA[

            this.__buttons = this.buttons;
            this.__buttonCount = this.buttonCount;
            this.__datasource = this.getDatasource();
            this.__labelField = this.labelField;
            this.__aclField = this.aclField;
            this.__imageField = this.imageField;
            this.__buttonClass = this.buttonClass;
            this.__selectedItems = this.selectedItems;
            this.__rowCount = this.rowCount;
            this.__startOffset = this.startOffset;

            var buttonCount = this.buttonCount;
            var startOffset = this.startOffset;
            var endOffset = startOffset+buttonCount;

            if ( index < startOffset || index > endOffset) return;

            this.renderButton(index);


        ]]>
        </body>
    </method>


    <method name="ensureIndexIsVisible">
      <parameter name="index" />
      <body>
            var pageSize = parseInt(this.rows) * parseInt(this.cols);
            var pageOffset = Math.floor(index / pageSize);
            this._startOffset = pageOffset * pageSize;
            this.startOffset = this._startOffset;
            this.render();
      </body>
    </method>


    <method name="resizeButtons">
        <body><![CDATA[

            var width = this.boxWidth;
            var height = this.boxHeight;
            var rows = parseInt(this.rows);
            var cols = parseInt(this.cols);
            //var btnWidth = Math.floor(width/cols);
            //var btnHeight = Math.floor(height/rows);
            var buttonCount = this.buttonCount;
            var buttons = this.buttons;

            // GREUtils.log('resizeButtons ' + width + ',,' + cols + ',,' + btnWidth );
            
            // Calculate the average width of buttons. Buttons are all set in initGrid so don't worry about the lack of buttons.
            var sumWidth = 0;
            for ( var i = 0; i < cols; i++ )
                sumWidth += buttons[ i ].boxWidth || 0;
            var btnWidth = Math.floor( ((sumWidth > 0) ? sumWidth : width ) / cols );
            
            // Calculate the average height of buttons.
            var sumHeight = 0;
            for ( var i = 0; i < rows; i++ )
                sumHeight += buttons[ i * cols ].boxHeight || 0;
            var btnHeight = Math.floor( ((sumHeight > 0) ? sumHeight : height ) / rows );
            
            for(let i=0; i < buttonCount ; i++) {
		       buttons[i].style['width'] = btnWidth +'px';
	           buttons[i].style['height'] = btnHeight +'px';
                //GREUtils.log('resizeButton ' + i +',,,' + btnWidth );
               try {
                 buttons[i].resizeLabel(btnWidth, btnHeight);
               }catch(e){
                //GREUtils.log('call button.resizeLabel ' + i + ',,,' + e );
               }
            } 

        ]]>  
        </body>
    </method>

    <method name="updateSelectedItemState">
        <body>
            <![CDATA[

            var buttons = this.buttons;
            var buttonCount = this.buttonCount;
            var selectedItems = this.selectedItems;
            var startOffset = this.startOffset;
            var seltype = this.seltype;

            // GREUtils.log('updateSelectedItemState ' + this.parentNode.parentNode.id + ' selectedItems = ' + selectedItems.join('||')  + ' ,offset = ' + startOffset );

            // update selectedItemGroup for all selecteditems
            selectedItems.forEach(function(idx) {

                    let seltype = this.getButtonSelectType(idx);
                    let selgroup = this.getButtonSelectGroup(idx);

                    if (seltype == 'single' || seltype == 'toggle') {
                        this._selectedItemGroups[selgroup] = idx;
                    }

            }, this);

            // update button checked state
            for(let i=0; i < buttonCount ; i++) {

                let row = startOffset + i;
               
                if (GeckoJS.Array.inArray(row, selectedItems) != -1) {

                    buttons[i].setAttribute('selected', true);
                    buttons[i].setAttribute('checked', true);

                }else {

                    buttons[i].removeAttribute('selected');
                    buttons[i].removeAttribute('checked');
                    
                }
            }

            ]]>
        </body>
    </method>

    <method name="setCheckedState">
        <parameter name="target" />
        <body><![CDATA[

            this.currentIndex = this.startOffset + parseInt(target.getAttribute('anonid'));

            var seltype = this.getButtonSelectType(this.currentIndex);
            var selgroup = this.getButtonSelectGroup(this.currentIndex);

            if (seltype == 'single' || seltype == 'toggle' ) {

                var preIndex = this._selectedItemGroups[selgroup];

                if ( typeof preIndex != 'undefined' && preIndex != this.currentIndex )  {
                   
                    // process prev index
                    this.selectedItems.splice(GeckoJS.Array.inArray(preIndex, this.selectedItems), 1);
                    this.selectedCount--;

                    if (preIndex >= this.startOffset && preIndex <= (this.startOffset+this.buttonCount)) {
                        var btnid = preIndex % this.buttonCount;
                        var btn = document.getAnonymousElementByAttribute(this, 'anonid', btnid);
                        if(btn) {
                            btn.removeAttribute('selected');
                            btn.removeAttribute('checked');
                        }
                    }

                }else if ( typeof preIndex != 'undefined' && preIndex == this.currentIndex ) {

                    if (seltype == 'toggle') {

                        this.selectedItems.splice(GeckoJS.Array.inArray(this.currentIndex, this.selectedItems), 1);
                        this.selectedCount--;

                        delete this._selectedItemGroups[selgroup];

                        target.removeAttribute('selected');
                        target.removeAttribute('checked');

                    }

                    return ;
                }

                this._selectedItemGroups[selgroup] = this.currentIndex;
                this.selectedItems.push(this.currentIndex);
                this.selectedCount++;

                target.setAttribute('selected', true);
                target.setAttribute('checked', true);
                    
            } else if (seltype == 'multiple') {

                // multiple
                if (GeckoJS.Array.inArray(this.currentIndex, this.selectedItems) == -1) {
                    this.selectedItems.push(this.currentIndex);
                    this.selectedCount++;
                    target.setAttribute('selected', true);
                    target.setAttribute('checked', true);
                }else {
                    this.selectedItems.splice(GeckoJS.Array.inArray(this.currentIndex, this.selectedItems), 1);
                    this.selectedCount--;
                    target.removeAttribute('selected');
                    target.removeAttribute('checked');
                }

            }


        ]]>
        </body>
    </method>


  </implementation>

  <handlers>
    <handler event="click" button="0"><![CDATA[

        // maybe click on row / grid
        // fixed click on row will unchecked all buttons at seltype=single
        var tagName = event.originalTarget.tagName.toLowerCase();
        var supportTagName = this.buttonTagName || 'vivibutton' ;
        if(tagName != supportTagName && tagName != 'button') {
            return ;
        }

        // make vivibuttonpanel has checked and selected state.
        if(event.originalTarget.getAttribute('disabled').toLowerCase() != 'true') {
            this.setCheckedState(event.originalTarget);
        }
        if(event.target == this) event.stopPropagation();
    ]]>
    </handler>
  </handlers>

</binding>
</bindings>
