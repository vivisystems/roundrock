<?xml version="1.0"?>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">


  <binding id="scrollablepanel" extends="chrome://global/content/bindings/scrollbox.xml#scrollbox-base">
    <content>
        
        <xul:hbox style="margin: 0px; padding:0px;" flex="1" anonid="scrollablepanel-container" class="scrollablepanel" xbl:inherits="class,flex,pack,dir">
            
            <xul:scrollbox style="margin: 0px; padding:0px;" orient="vertical" xbl:inherits="orient,align,pack" flex="1" anonid="scrollbox">
              <children/>
            </xul:scrollbox>
            
            <xul:vbox style="margin: 0px; padding:0px;" class="scrollablepanel-scrollbar" xbl:inherits="class=scrollbarClass" anonid="scrollbar" >
                <xul:button label="UP" anonid="scrollbutton-up" oncommand="_autorepeatbuttonScroll(event);" xbl:inherits="class=scrollUpClass"></xul:button>
                <xul:spacer flex="1"/>
                <xul:button label="DOWN" anonid="scrollbutton-down" oncommand="_autorepeatbuttonScroll(event);" xbl:inherits="class=scrollDownClass"></xul:button>
            </xul:vbox>
        </xul:hbox>
        
    </content>

    <implementation>
      <field name="_scrollbox">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbox");
      </field>
      <field name="_scrollButtonUp">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-up");
      </field>
      <field name="_scrollButtonDown">
        document.getAnonymousElementByAttribute(this, "anonid", "scrollbutton-down");
      </field>

      <field name="__prefBranch">null</field>
      <property name="_prefBranch" readonly="true">
        <getter><![CDATA[
          if (this.__prefBranch === null) {
            this.__prefBranch = Components.classes['@mozilla.org/preferences-service;1']
                                          .getService(Components.interfaces.nsIPrefBranch2);
          }
          return this.__prefBranch;
        ]]></getter>
      </property>

      <field name="_scrollIncrement">null</field>
      <property name="scrollIncrement" readonly="true">
        <getter><![CDATA[
          if (this._scrollIncrement === null) {
            try {
                if(this.hasAttribute('increment')) this._scrollIncrement = parseInt(this.getAttribute('increment'));
		else this._scrollIncrement = this._prefBranch.getIntPref("toolkit.scrollbox.scrollIncrement");
            }
            catch (ex) {
              this._scrollIncrement = 20;
            }
          }
          return this._scrollIncrement;
        ]]></getter>
      </property>

      <field name="_smoothScroll">null</field>
      <property name="smoothScroll">
        <getter><![CDATA[
          if (this._smoothScroll === null) {
            if (this.hasAttribute("smoothscroll")) {
              this._smoothScroll = (this.getAttribute("smoothscroll") == "true");
            } else {
              try {
                this._smoothScroll = this._prefBranch
                                         .getBoolPref("toolkit.scrollbox.smoothScroll");
              }
              catch (ex) {
                this._smoothScroll = true;
              }
            }
          }
          return this._smoothScroll;
        ]]></getter>
        <setter><![CDATA[
          this._smoothScroll = val;
          return val;
        ]]></setter>
      </property>

      <field name="_scrollBoxObject">null</field>
      <property name="scrollBoxObject" readonly="true">
        <getter><![CDATA[
          if (!this._scrollBoxObject) {
            this._scrollBoxObject =
              this._scrollbox.boxObject
                             .QueryInterface(Components.interfaces.nsIScrollBoxObject);
          }
          return this._scrollBoxObject;
        ]]></getter>
      </property>

      <field name="_isLTRScrollbox">
        document.defaultView.getComputedStyle(this._scrollbox, "").direction == "ltr";
      </field>

      <method name="ensureElementIsVisible">
        <parameter name="element"/>
        <body><![CDATA[
          if (!this.smoothScroll || this.getAttribute("orient") == "vertical") {
            this.scrollBoxObject.ensureElementIsVisible(element);
            return;
          }

          var rect = this._scrollbox.getBoundingClientRect();
          var containerStart = rect.left;
          var containerEnd = rect.right;
          rect = element.getBoundingClientRect();
          var elementStart = rect.left;
          var elementEnd = rect.right;
          var amountToScroll;

          if (elementStart < containerStart) {
            amountToScroll = elementStart - containerStart;
          } else if (containerEnd < elementEnd) {
            amountToScroll = elementEnd - containerEnd;
          } else if (this._isScrolling) {
            // decelerate if a currently-visible element is selected during the scroll
            const STOP_DISTANCE = 15;
            if (this._isScrolling == -1 && elementStart - STOP_DISTANCE < containerStart)
              amountToScroll = elementStart - containerStart;
            else if (this._isScrolling == 1 && containerEnd - STOP_DISTANCE < elementEnd)
              amountToScroll = elementEnd - containerEnd;
            else
              amountToScroll = this._isScrolling * STOP_DISTANCE;
          } else {
            return;
          }

          this._smoothScrollByPixels(amountToScroll);
        ]]></body>
      </method>

      <method name="_smoothScrollByPixels">
        <parameter name="amountToScroll"/>
        <body><![CDATA[
          this._stopSmoothScroll();

          // Positive amountToScroll makes us scroll right (elements fly left), negative scrolls left.
          var round;
          if (amountToScroll < 0) {
            this._isScrolling = -1;
            round = Math.floor;
          } else {
            this._isScrolling = 1;
            round = Math.ceil;
          }

          const FRAME_LENGTH = 60;

          function processFrame(self, scrollAmounts, off) {
            var distance = scrollAmounts.shift();

            // Skip frames if we aren't getting the desired frame rate.
            if (off > 0) {
              for (var i = Math.round(off / FRAME_LENGTH); i > 0; i--)
                distance += scrollAmounts.shift() || 0;
            }

            self.scrollBoxObject.scrollBy(distance, 0);
            if (!scrollAmounts.length)
              self._stopSmoothScroll();
          }

          // amountToScroll: total distance to scroll
          // scrollAmount: distance to move during the particular effect frame (60ms)
          var scrollAmount, scrollAmounts = [];
          if (amountToScroll > 2 || amountToScroll < -2) {
            scrollAmount = round(amountToScroll * 0.2);
            scrollAmounts.push(scrollAmount, scrollAmount, scrollAmount);
            amountToScroll -= 3 * scrollAmount;
          }
          while (this._isScrolling < 0 && amountToScroll < 0 ||
                 this._isScrolling > 0 && amountToScroll > 0) {
            amountToScroll -= (scrollAmount = round(amountToScroll * 0.5));
            scrollAmounts.push(scrollAmount);
          }
          this._smoothScrollTimer = setInterval(processFrame, FRAME_LENGTH, this, scrollAmounts);
          processFrame(this, scrollAmounts, 0);
        ]]></body>
      </method>

      <method name="scrollByIndex">
        <parameter name="index"/>
        <body><![CDATA[
          if (index == 0)
            return;
          if (this.getAttribute("orient") == "vertical") {
            this.scrollBoxObject.scrollByIndex(index);
            return;
          }

          var x;
          if (index > 0)
            x = this._scrollbox.getBoundingClientRect().right + 1;
          else
            x = this._scrollbox.getBoundingClientRect().left - 1;
          var nextElement = this._elementFromPoint(x);
          if (!nextElement)
            return;

          var targetElement;
          if (!this._isLTRScrollbox)
            index *= -1;

          while (index < 0 && nextElement) {
            targetElement = nextElement;
            nextElement = nextElement.previousSibling;
            index++;
          }
          while (index > 0 && nextElement) {
            targetElement = nextElement;
            nextElement = nextElement.nextSibling;
            index--;
          }

          this.ensureElementIsVisible(targetElement);
        ]]></body>
      </method>

      <method name="_elementFromPoint">
        <parameter name="aX"/>
        <body><![CDATA[
          var elements = this.hasChildNodes() ?
                         this.childNodes :
                         document.getBindingParent(this).childNodes;
          if (!this._isLTRScrollbox) {
            elements = Array.slice(elements);
            elements.reverse();
          }
          var low = 0;
          var high = elements.length - 1;

          while (low <= high) {
            var mid = Math.floor((low + high) / 2);
            var element = elements[mid];
            var rect = element.getBoundingClientRect();
            if (rect.left > aX)
              high = mid - 1; 
            else if (rect.right < aX)
              low = mid + 1;
            else
              return element;
          }

          return null;
        ]]></body>
      </method>

      <method name="_autorepeatbuttonScroll">
        <parameter name="event"/>
        <body><![CDATA[
          var dir = event.originalTarget == this._scrollButtonUp ? -1 : 1;
          if (this.getAttribute("orient") == "horizontal" && !this._isLTRScrollbox)
            dir *= -1;

          this.scrollByPixels(this.scrollIncrement * dir);

          event.stopPropagation();
        ]]></body>
      </method>

      <method name="scrollByPixels">
        <parameter name="px"/>
        <body><![CDATA[
          if (this.getAttribute("orient") == "horizontal")
            this.scrollBoxObject.scrollBy(px, 0);
          else
            this.scrollBoxObject.scrollBy(0, px);
        ]]></body>
      </method>

      <!-- 0: idle
           1: scrolling right
          -1: scrolling left -->
      <field name="_isScrolling">0</field>
      <field name="_smoothScrollTimer">0</field>

      <method name="_stopSmoothScroll">
        <body><![CDATA[
          clearInterval(this._smoothScrollTimer);
          this._isScrolling = 0;
        ]]></body>
      </method>

      <method name="_updateScrollButtonsDisabledState">
        <body><![CDATA[
          var disableUpButton = false;
          var disableDownButton = false;

          if (this.getAttribute("orient") == "horizontal") {
            var width = {};
            this.scrollBoxObject.getScrolledSize(width, {});
            var xPos = {};
            this.scrollBoxObject.getPosition(xPos, {});
            if (xPos.value == 0) {
              // In the RTL case, this means the _last_ element in the
              // scrollbox is visible
              if (this._isLTRScrollbox) 
                disableUpButton = true;
              else
                disableDownButton = true;
            }
            else if (this._scrollbox.boxObject.width + xPos.value == width.value) {
              // In the RTL case, this means the _first_ element in the
              // scrollbox is visible
              if (this._isLTRScrollbox)
                disableDownButton = true;
              else
                disableUpButton = true;
            }
          }
          else {  // vertical scrollbox
            var height = {};
            this.scrollBoxObject.getScrolledSize({}, height);
            var yPos = {};
            this.scrollBoxObject.getPosition({}, yPos);
            if (yPos.value == 0)
              disableUpButton = true;
            else if (this._scrollbox.boxObject.height + yPos.value == height.value)
              disableDownButton = true;
          }

          if (this._scrollButtonUp.disabled != disableUpButton ||
              this._scrollButtonDown.disabled != disableDownButton) {
            this._scrollButtonUp.disabled = disableUpButton;
            this._scrollButtonDown.disabled = disableDownButton;

            var event = document.createEvent("Events");
            event.initEvent("UpdatedScrollButtonsDisabledState", true, false);
            this.dispatchEvent(event);
          }
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="DOMMouseScroll" action="this.scrollByIndex(event.detail); event.stopPropagation();"/>

      <handler event="underflow"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // Ignore events that doesn't match our orientation.
        // Scrollport event orientation:
        //   0: vertical
        //   1: horizontal
        //   2: both
        if (this.getAttribute("orient") == "horizontal") {
          if (event.detail == 0) {
            return;
          }
        }
        else {    // vertical scrollbox
          if (event.detail == 1) {
            return;
          }
        }

        this._scrollButtonUp.collapsed = true;
        this._scrollButtonDown.collapsed = true;
        try {
          // See bug 341047 and comments in overflow handler as to why 
          // try..catch is needed here
          var childNodes = document.getAnonymousNodes(this._scrollbox);
          if (childNodes && childNodes.length)
            this.scrollBoxObject.ensureElementIsVisible(childNodes[0]);
        }
        catch(e) {
          this._scrollButtonUp.collapsed = false;
          this._scrollButtonDown.collapsed = false;
        }
      ]]></handler>

      <handler event="overflow"><![CDATA[
        // filter underflow events which were dispatched on nested scrollboxes
        if (event.target != this)
          return;

        // Ignore events that doesn't match our orientation.
        // Scrollport event orientation:
        //   0: vertical
        //   1: horizontal
        //   2: both
        if (this.getAttribute("orient") == "horizontal") {
          if (event.detail == 0) {
            return;
          }
        }
        else {    // vertical scrollbox
          if (event.detail == 1) {
            return;
          }
        }

        this._scrollButtonUp.collapsed = false;
        this._scrollButtonDown.collapsed = false;
        try {
          // See bug 341047, the overflow event is dispatched when the 
          // scrollbox already is mostly destroyed. This causes some code in
          // _updateScrollButtonsDisabledState() to throw an error. It also
          // means that the scrollbarbuttons were uncollapsed when that should
          // not be happening, because the whole overflow event should not be
          // happening in that case.
          this._updateScrollButtonsDisabledState();
        } 
        catch(e) {
          this._scrollButtonUp.collapsed = true;
          this._scrollButtonDown.collapsed = true;
        }
      ]]></handler>

      <handler event="scroll" action="this._updateScrollButtonsDisabledState()"/>
    </handlers>
  </binding>
  
</bindings>
